

## 1. 第二周直播时说的遗留问题，对象同时存在强弱引用时，是同一个内存区域有多种不同指针还是会开辟内存区域。比如Thread对象里面的ThreadLocalMap中Entry的键。


对象同时存在强弱引用时，是同一个内存区域有多种不同指针的.

![image-20211025173620073](/Users/zhang/Documents/lagou/lagou_private_education/周中答疑复盘/image-20211025173620073-5154581.png)

## 2. 可达性分析中

1. ## 什么情况下需要进行执行第二次标记

2. ## finalize() 重写后的方法中，重新给标记的对象 进行 赋值，是不是这个对象将永久存在不会被GC

   可达性分析中只要存在并发标记的时候，应该都需要进行第二次标记，因为在并发标记中有可能会存在漏标和多标错误，漏标是不能容忍的，漏标会将本来存活的对象未标记为存活会导致出现重大问题。

   2. 如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。

   即覆盖finalize 方法并且重新让对象建立连接后，则可以被逃脱。

   但是 finalize 方法只会执行一次，如果对象在被调用finalize方法后 再次被jvm标记为可回收，则不会再次调用finalize方法，finalize 方法的执行是由 F-Queue 记录的

   ![image-20211025174050193](/Users/zhang/Documents/lagou/lagou_private_education/周中答疑复盘/image-20211025174050193-5154851.png)

## 3. 线程池中的，ThreadPoolExecutor.CallerRunsPolicy  怎么理解，它是会立即执行最新任务，并堵塞掉原有执行的队列的意思吗？并且怎么完美的设计一个能保证任务不被丢弃的的线程池。

当线程池中工作线程数达到最大值，阻塞队列也已经满了，就会直接让主线程去执行调用 Runnable 的 run() 方法执行任务。主线程就会被堵塞，等待主线程执行完成后，新的任务才能放入队列中

## 4. 请问星辰教练，CMS“并发失败”（Concurrent Mode failure）是怎么回事？什么情况会发生并发失败？

发生在：并发清理的时候会导致分配空间不足

具体：在执行CMS GC的过程中同时业务线程将对象放入老年代，而此时老年代空间不足，或者在做Minor GC的时候，新生代Survivor空间放不下，需要放入老年代，而老年代也放不下而产生的。

由于 CMS的并发操作,在并发清除的时候,也可以进行用户线程操作,对象可以进行写入,所以需要预留一部分使用空间。

如果业务上你的应用就是一直不停地在分配对象,那么建议配置来改变预留用户线程内存的比例  XX：CMSInitiatingOccupancyFraction

## 5. ArrayList 用完后， cms 频繁 gc，老年代内存却没有降下来是为什么？


在ArrayList 动态扩容的时候有可能会存在内存泄露。



## 6. 周末直播遗留问题——并发标记阶段黑色对象可能重新引用白色对象，并发清除阶段也会发生吗?


在cms 重新标记时会根据incremental update算法来重新标记漏标的对象，在并发清理时不会存在一个对象忽然被引用的情况。**CMS操作 只会对之前标记的对象进行清理，对于浮动垃圾需要等待下一次GC操作的时候进行删除**

## 7. 周末直播遗留问题——有没有办法通过句柄，重新引用“垃圾”？


句柄就像 Java 层面的指针，可以修改某个属性内存地址处的内容，但得传入对象和属性名，JVM 才能计算出地址。它并不能把“垃圾”找回来。

**句柄不能当做根对象也不能避免对象被垃圾回收**

## 8. 安全点和安全区域的作用是什么？

**安全点:**  程序执行时并非在所有地方都能停顿下来开始GC ， 只有在特定的位置才能停顿下来开始GC ， 这些位置称为“ 安全点（Safepoint）

安全点的选择很重要， 如果太少可能导致GC 等待的时间太长， 如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“ 是否具有让程序长时间执行的特征” 为标准。比如： 选择一些执行时间较长的指令作为safe Point ，如：

- 循环的末尾
- 方法临返回前
- 调用方法之后
- 抛异常的位置


二者的作用都是为了避免发生引用的改变，导致用户线程执行时出现安全问题。

## 9. G1 内存布局变成等分的 Region，那 Mixed GC 是怎么进行分代回收的？

![image-20211025170428016](/Users/zhang/Documents/lagou/lagou_private_education/周中答疑复盘/image-20211025170428016-5152673.png)

[https://www.cnblogs.com/peterleee/p/10528468.html](https://www.cnblogs.com/peterleee/p/10528468.html)

## 10. jvm为什么用元空间替换永久代？

因为之前的永久代可以设置大小，但是在具体项目中是无法估计出合理的大小，导致在回收永久代时无法合理回收，或者回收不彻底，之前jvm的很多bug都是这个引起的，因此换成了元空间，
元空间的空间理论上是能跟系统内存一样大的，并且垃圾的回收是系统来处理更高效合理。

更深层的原因还是要合并HotSpot和JRockit的代码，JRockit从来没有所谓的永久代，也不需要开发运维人员设置永久代的大小，但是运行良好。同时也不用担心运行性能问题了,在覆盖到的测试中, 程序启动和运行速度降低不超过1%，但是这点性能损失换来了更大的安全保障。

**没有了永久代，回收算法也变简单安全了**

## 11. 方法走完，引用消失，堆内存还未必消失。好多人在做报表导出的时候，就会在for循环里不断的创建对象，很容易造成堆溢出，那像这种大文件导出的时候要怎么处理呢？

使用分页思想分批执行，执行完成后释放资源。考虑切片技术，将大文件切小，读一部分回收一部分。用时间来换空间。


## 12.  请问教练，每一个Java对象关联的ObjectMonitor是什么时候创建的，这个monitor锁和对象的关系是什么？我看有些博客上说Monitor是线程私有的数据结构，我理解Monitor应该只有一个，和对象是一一对应的。


ObjectMonitor对象是在锁升级为重量级锁时候会生成一个ObjectMonitor对象，然后将对象的地址值存放到mark word上面。

![img](/Users/zhang/Documents/lagou/lagou_private_education/周中答疑复盘/v2-770c0db5330d3ca0a4e4228205a796ef_1440w.jpg)

objectmonitor会记录等待和阻塞的线程,只是某一时刻只有一个线程拥有它, 是作为锁来使用的。一个重量级锁对象会拥有一个objectmonitor;

## 14. 请问教练，在cms并发清除的时候，如何保证新生代晋级到老年代的对象不被清除。

新生代晋级到老年代的对象是不会被清除的

在CMS回收过程中,还应该确保应用程序用户线程有足够的内存可用。因此,CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集,而是当堆内存使用率达到某一阈值时,便开始进行回收,以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要(生成垃圾的速度快过清理的速度),就会出现一次“Concurrent Mode Failure”失败,这时虚拟机将启动后备预案:临时启用Serial 0ld收集器来重新进行老年代的垃圾收集,这样停顿时间就很长了。

CMS收集器的垃圾收集算法采用的是标记一清除算法,这意味着每次执行完内存回收后,由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块,不可避免地将会产生一些内存碎片。 那么CMS在为新对象分配内存空间时,将无法使用指针碰撞(Bump the Pointer) 技术,而只能够选择空闲列表(Free List) 执行内存分配。