## 1. 请问星辰教练，对于DDD的看法，最近公司要大力推行DDD，对于这个模式，我们在实际项目中应该如何使用，有什么需要注意的？

解答: 最简单的实践方法，以前我们设计系统是先设计表结构。DDD倡导的是反向思维，先设计接口驱动设计表结构。参考链接: https://tech.meituan.com/2017/12/22/ddd-in-practice.html

## 2. 请问星辰教练，之前面试的时候有被问到数据库为什么需要binlog日志，redo日志，undo日志，我只知道有这么三个日志，分别是干什么的，不知道为什么，还是想要了解一下

解答: 1. binlog会记录所有的数据库修改操作，主要用于主从复制和数据恢复。

2) redo日志和undo日志是innodb的机制。
   redo日志是防止断电或宕机缓存没有及时写入文件系统。
   undo日志主要用于事物回滚和mvcc
3) 

## 3. 请问星辰教练，最近在看java内存区域，在方法执行时会向虚拟机中压栈，栈帧中有局部变量表。局部变量表里存的是方法内的变量。请问这些变量是在压栈前就确定好的，还是程序执行到对应字节码，再向局部变量表中添加的？

解答: 在压栈前就确定好的。为了jvm的性能，提升速度，如果过程中初始化的话分配内存和等一系列操作非常耗时。

扩展: 全局变量static一般在类加载器准备的阶段就已经加载到方法区之中了，并且会给它赋一个初始化的零值比如说0，null之类的，然后再把程序员初始化的值赋给成员变量。而局部变量却不是这样的，它没有在方法区之中，相对于全局变量，局部变量的生命周期短，声明次数多，如果像全局变量一样给个初始值的话会影响性能，不给初始值又不安全，所以折中了一下，规定了用户需要先赋值再使用。如果没有初始化，类似c的随便指了一个地址。所以java直接编译失败了。

## 4. 定时任务同步开户数据（第3方数据库），希望达到近实时效果。目前方案是配置从哪条开户记录开始同步，用表id字段标识，每隔5分钟，按id取增量用户，每次同步后，写数据库表记录已同步记录最大id，下一轮定时任务再次基础上取数据。 

## 关键点1：单独建一张表1个字段，存记录最大id,供定时任务取增量数据，是否大动干戈？

## 关键点2：如何保证定时任务失败了，能有相关机制重新同步失败数据（当然已同步数据再同步的话目前程序可自动过滤）

解答: 1.写到redis 2.如果失败不更新redis最大值、并且业务测做幂等

扩展: 如果数据库挂了怎么办？redis可用性比数据库高的且都有容灾机制的。

​			时效性的保证: 要时效性的话，最好用推的方式，要么定时任务缩短时间。一般都是推拉结合。



## 5. 请问星辰教练，下面是我的两个问题，麻烦解答

## 1.面试的时候被问怎么设计一个分布式锁，我把redis那套说了，他说要自己设计，不能回答redis的。 

## 2.当线上积压了大量mq消息，怎么处理，如果都比较重要不能丢弃的情况？

解答: 

​			1.可以用数据库做分布式锁。也可以自己写个服务,用java的锁机制实现(排他锁),加上租约机制,再加个超时时间,再写个持久化机制。

			2. 提高消费端消费能力或者批量消费。重要程度高的话 可以加个异常重试队列



## 6. 请问星辰教练，今天工作上碰到一个SQL的一个not in的优化问题。类似于下面的例子，有两张表A和B, 都有字段id, 想查询select * from A where id not in (select id from B);我改成select * from B left join B on A.id = B.id and B.id is null;之后，速度快了很多，记得以前面试的时候也被问过not in的优化问题，网上通常给的答案是not exists, 今天发现left join也很快。想问一下上面的两条SQL的内部原理有什么不一样，not exists的原理又是什么？

解答:  left join  是会走索引的，另外执行顺序是先把匹配的id都找出来，然后再把null的去掉。其实mysql的执行器和咱们的代码一样，如果是关联查询就要做逻辑判断。把sql会拆成几个子语句，然后再做最终匹配。这样就增加很多次磁盘IO。

理解: 一样效果的sql语句应该是 select * from A left join B on A.id = B.id where B.id is null。explain发现多了一条 select_type为MATERIALIZED的记录，表明mysql会创建临时表，对两表都进行全表扫描会有笛卡尔积的问题。