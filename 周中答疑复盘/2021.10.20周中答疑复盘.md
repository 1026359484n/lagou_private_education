## 1.jvm老年代提供的空间分配担保，若是对象太大多次担保失败，jvm会抛异常还是怎么处理

​	空间分配担保时发现内存不够就会fullGC，gc之后还不够就说明担保失败，就会OOM。

## 2. 运行时常量池和常量池分别包含哪些数据，都是存放在元空间吗？

  静态常量池：常量池表，编译期生成的各种字面量和符号引用，以及类加载后会存放到方法区的运行时常量池中

  运行时常量池：编译器生成的各种字面量和符号引用在类加载后会存入，以及运行过程中新生成的常量都在元空间

  jvm中概念很多，学知识点有种管中窥豹的感觉，如何成体系的掌握好这块内容？

  《深入理解JVM》等书籍多看，平时多研究，多思考，多练习，落实到博客

## 3. **元空间垃圾收集要满足那些条件**

​	a.类及其子类的所有实例都被回收

​	b.类对应的class 对象没有在任何地方引用

​	c.类加载器已经被回收

## **4.MESI的一致性协议，JMM的8大原子操作步骤**

M(Modified)这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。

E(Exclusive)这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。

S(Shared)这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。

I(Invalid) 这行数据无效。

lock(锁定)：作用于主内存，它把一个变量标记为一条线程独占状态；

read(读取)：作用于主内存，它把变量值从主内存传送到线程的工作内存中，以便随后的load动作使用；

load(载入)：作用于工作内存，它把read操作的值放入工作内存中的变量副本中；

use(使用)：作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时候，将会执行这个动作；

assign(赋值)：作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时候，执行该操作；

store(存储)：作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的write操作使用；

write(写入)：作用于主内存，它把store传送值放到主内存中的变量中。

unlock(解锁)：作用于主内存，它将一个处于锁定状态的变量释放出来，释放后的变量才能够被其他线程锁定；

## 5.**JVM优化思路，大促销的内存分配思路**

首先最重要的思路是防止频繁Full gc,以及减少MinoGC,合理分配新生代和老年代的比例， 以及新生代内部的eden和survive的比例，对于朝生夕死的对象可以按情况扩大新生代比例， 但不是越大越好，因为复制耗时比扫描耗时更久，对于存在多数存活久的对象，应该尽量让其早点进入老年代，来减少MinoGC，上线之前做压测，不断调整 -XX:NewRatio 和 XX:SurvivorRatio 的值，来达到相对理想状态。

总结：**主要是减少FullGC 频率，调优新生代与老年代比例采用高吞吐量的垃圾回收机制，调优垃圾回收时的STW时间**

## 6. MySQL数据库什么场景会使用到MyISAM引擎，什么场景会使用到Memory引擎？

对事务没有要求的场景，一般都是读多写少，数据一致性要求不高

对于Memory引擎的表：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。

现在一般情况下都使用InnoDB

## 7.在数据库选型时，mysql和mongodb两种数据库各侧重于哪些场景？

   a.mysql对事务支持的较好，支持SQL标准,关。型数据

   b.mongodb的优点是读写性能好，灵活文档模型、高可用复制集、可扩展分片集群，非关系型

## 8.MySQL双机热备，加异地机房 高可用模式具体是怎么实现的？

  mha,databus,canal.三方中间件同步binlog,双机房加节点，同一个集群

## 9. 当mysql 服务器cpu 100%，如何排查

一般这种情况下，业务日志会持续报错，首要的是止损，然后看连接池的监控，再看慢查询

获取不到连接或者timeout,如果没有慢查询，那说明是流量过大，集群无法负载

如果流量过大，就得加从库，再不行就分库分表，再不行就得换存储方案