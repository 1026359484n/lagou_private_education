1. 如何辨别哪些部分线程共享？哪些部分是线程隔离的？判断依据是什么？
   堆是共享的，堆里面存储的是对象实例，多个线程通信可能会出现需要共享相同的对象实例的情况，如果线程隔离，那么线程间无法共享对象实例，不利于节省内存空间，且线程间无法通信，所以堆需要线程共享。注: 对不需要线程间共享的实例会在堆上划分一块名为TLAB的线程私有的分配缓冲区,以提升对象分配时的效率。

   程序计数器记录的是代码执行的位置，如果线程共享，比如线程A执行到25行，这时候线程B从头执行，然后切换回线程A,这时候就会找不到线程A执行的位置，所以需要线程隔离；
   同理，虚拟机栈和本地方法栈是通过先进后出的栈结构记录方法的调用，每调用一个方法即执行一次栈帧的压入和弹出操作，如果线程共享的话，线程A压栈方法X，再压入方法Y，然后切换到线程B，压入线程X，再切换会线程A,这时候程序的执行就会混乱，因为这时候线程A应该是弹出方法Y，但是栈的顶端是线程B压入的方法X。

2. 为什么虚拟机栈与本地方法栈被称之为“栈”？

   栈的结构是先进后出，虚拟机栈和本地方法栈通过这样数据结构实现java方法和本地方法的调用，进入方法为压入栈帧，方法执行完成弹出对应栈帧。所以称为“栈”

3. SOF的原因可能是什么？

   在《Java虚拟机规范》描述了SOF异常: 线程请求的栈深度大于虚拟机所允许的最大深度将抛出SOF异常。对hotspot来说，栈的大小不支持动态扩展，是在程序启动时通过-Xss参数指定的，可以调节，且在不同版本，不同系统有不同的最小限制和默认值，如m1 mac 默认1024KB 最小值208k。在栈的大小固定的情况小，如果递归调用或循环调用导致栈深度太深，就会报SOF。注:栈帧中局部变量表的大小会影响栈的可压入深度，局部变量表越大则可压入的栈深度越小。

4. 哪些部分会被垃圾回收机制重点关注？判断依据是什么？

   虚拟机栈和本地方法栈与线程绑定，随线程生死，容易管理。堆内存中对象可能线程间共享，重点关注。

5. 栈帧中 基本类型直接存储在局部变量表内，引用类型只是在局部变量表中存储引用的地址。如果一个方法中基本类型的变量过多 会不会导致StackOverFlowError?

   当线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError，一般是递归调用或循环调用(A，B方法互相调用)没有结束。

   JVM 提供了参数来设置虚拟机栈的大小【Xss 和 ThreadStackSize】，同样的虚拟机栈大小，栈深度取决于调用的方法需要分配多少内存。

   如果方法的本地变量很多，那每个栈帧需要的内存就越多，那么最大栈深度就越小。

   另外，如果虚拟机栈的容量可以动态扩展（HotSpot不允许），当扩展的时候无法申请到足够的内存就会抛出 OutOfMemoryError 异常。

   